// class set to represent a disjoint set
class Set {
  public: 
    int val;
    int size;
    Set(int val, int size) : val(val), size(size){};
};

// custom comparator for setting comparison criteria for pq
bool operator<(const Set &s1 ,const Set &s2){
  if(s1.size==s2.size) return s1.val>s2.val;
  return s1.size<s2.size;
}

class Solution {
public:
    vector<int> parent;
  
    int findParent(int node){
      if(parent[node]==node) return node;
      return parent[node]= findParent(parent[node]);
    }
  
    void Union(int u, int v){
      parent[findParent(u)]= findParent(v);
    }
  
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial){
        int n= graph.size(); // number of nodes
        
        for(int i=0; i<n; ++i) parent.push_back(i); // create n disjoint sets
        
        // take the union of nodes connected with each other
        for(int i=0; i<n; ++i)
          for(int j=i+1; j<n; ++j)
            if(graph[i][j]) Union(i, j);
      
        vector<int> size(n, 0), malware(n, 0);
        
        // finding the size of each set
        for(int i=0; i<n; ++i)
          size[findParent(i)]++; 
        
        // finding the malware count of each set
        for(auto it: initial) 
          malware[findParent(it)]++;
        
        priority_queue<Set> pq; // priority queue to store all sets with malware count of 1
        
        for(auto it: initial){
          if(malware[findParent(it)]==1){ // push all the sets with malware count 1
            pq.push(Set(it, size[findParent(it)]));
          }
        }
      
       // if there is no set with malware count 1, return minimum index from initial
       if(pq.empty()) return *min_element(initial.begin(), initial.end());
       // else return the set having the greatest size
       return pq.top().val;
    }
};