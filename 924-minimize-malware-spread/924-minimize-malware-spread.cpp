class Set {
  public: 
    int val;
    int size;
    Set(int val, int size) : val(val), size(size){};
};

bool operator<(const Set &s1 ,const Set &s2){
  if(s1.size==s2.size) return s1.val>s2.val;
  return s1.size<s2.size;
}

class Solution {
public:
    vector<int> parent;
  
    int findParent(int node){
      if(parent[node]==node) return node;
      return parent[node]= findParent(parent[node]);
    }
  
    void Union(int u, int v){
      parent[findParent(u)]= findParent(v);
    }
  
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial){
        int n= graph.size();
        
        for(int i=0; i<n; ++i) parent.push_back(i);
        
        for(int i=0; i<n; ++i)
          for(int j=i+1; j<n; ++j)
            if(graph[i][j]) Union(i, j);
      
        vector<int> size(n, 0), malware(n, 0);
        
        for(int i=0; i<n; ++i)
          size[findParent(i)]++;
      
        for(auto it: initial) 
          malware[findParent(it)]++;
        
        priority_queue<Set> pq;
        
        for(auto it: initial){
          if(malware[findParent(it)]==1){
            Set s= Set(it,size[findParent(it)]);
            pq.push(s);
          }
        }
        
       if(pq.size()==0) return *min_element(initial.begin(), initial.end());
       return pq.top().val;
    }
};