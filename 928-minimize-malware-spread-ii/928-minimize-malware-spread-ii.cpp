class Solution {
public:
    // function to find parent of a node
    int findParent(int node, vector<int> &parent){
      if(parent[node]==node) return node;
      return parent[node]= findParent(parent[node], parent);
    }
  
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n= graph.size();
        vector<int> parent(n);
      
        // create n disjoint sets
        for(int i=0; i<n; ++i) parent[i]= i; 
      
        // set of infected nodes
        set<int> infected(initial.begin(), initial.end());
      
        // set of clean nodes i.e. uninfected nodes
        set<int> clean;
        for(int i=0; i<n; ++i) if(!infected.count(i)) clean.insert(i);
      
        // take union of non-malware nodes that are connected
        for(auto i: clean)
          for(auto j: clean)
            if(i!=j && graph[i][j]) parent[findParent(i, parent)]= findParent(j, parent);
        
        // size of clean sets
        vector<int> size(n, 0);
        for(auto it: clean) size[findParent(it, parent)]++;
        
        map<int,set<int>> malware_connect; // to store the sets that are connected to a malware node
        map<int,int> union_connect; // to store the number of malwares that are connected to a clean set
      
        for(auto node: infected){
          for(auto it: clean) if(graph[node][it]) malware_connect[node].insert(findParent(it, parent));
          for(auto set: malware_connect[node]) union_connect[set]++;
        }
        
        // compute the final ans
        int ans= *infected.begin();
        int max_count= -1;
        for(auto malware: infected){
          int count= 0;
          for(auto clean_sets: malware_connect[malware]) if(union_connect[clean_sets]==1) count+=size[clean_sets];
          if(count>max_count || (count==max_count && malware<ans)){max_count= count; ans= malware;}
        }
      
      return ans;
    }
};